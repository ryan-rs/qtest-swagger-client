# coding: utf-8

"""
    qTest Manager API Version 8.6 - 9.0

    qTest Manager API Version 8.6 - 9.0

    OpenAPI spec version: 8.6 - 9.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class AttachmentApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def delete(self, project_id, blob_handle_id, object_type, object_id, **kwargs):
        """
        Deletes an Attachment from an Object
        To delete an Attachment from a Release, Build, Requirement, Test Case, Test Log, Test Step or Defect  <strong>qTest Manager version:</strong> 7.5+
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete(project_id, blob_handle_id, object_type, object_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: ID of the project (required)
        :param int blob_handle_id: ID of the Attachment (required)
        :param str object_type: Valid values include releases, builds, requirements, test-cases, test-logs, test-steps or defects  <strong>qTest Manager version:</strong> 4+ (required)
        :param int object_id: ID of the object (Release, Build, Requirement, Test Case, Test Log, Test Step or Defect) (required)
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_with_http_info(project_id, blob_handle_id, object_type, object_id, **kwargs)
        else:
            (data) = self.delete_with_http_info(project_id, blob_handle_id, object_type, object_id, **kwargs)
            return data

    def delete_with_http_info(self, project_id, blob_handle_id, object_type, object_id, **kwargs):
        """
        Deletes an Attachment from an Object
        To delete an Attachment from a Release, Build, Requirement, Test Case, Test Log, Test Step or Defect  <strong>qTest Manager version:</strong> 7.5+
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_with_http_info(project_id, blob_handle_id, object_type, object_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: ID of the project (required)
        :param int blob_handle_id: ID of the Attachment (required)
        :param str object_type: Valid values include releases, builds, requirements, test-cases, test-logs, test-steps or defects  <strong>qTest Manager version:</strong> 4+ (required)
        :param int object_id: ID of the object (Release, Build, Requirement, Test Case, Test Log, Test Step or Defect) (required)
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'blob_handle_id', 'object_type', 'object_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete`")
        # verify the required parameter 'blob_handle_id' is set
        if ('blob_handle_id' not in params) or (params['blob_handle_id'] is None):
            raise ValueError("Missing the required parameter `blob_handle_id` when calling `delete`")
        # verify the required parameter 'object_type' is set
        if ('object_type' not in params) or (params['object_type'] is None):
            raise ValueError("Missing the required parameter `object_type` when calling `delete`")
        # verify the required parameter 'object_id' is set
        if ('object_id' not in params) or (params['object_id'] is None):
            raise ValueError("Missing the required parameter `object_id` when calling `delete`")


        collection_formats = {}

        resource_path = '/api/v3/projects/{projectId}/{objectType}/{objectId}/blob-handles/{blobHandleId}'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']
        if 'blob_handle_id' in params:
            path_params['blobHandleId'] = params['blob_handle_id']
        if 'object_type' in params:
            path_params['objectType'] = params['object_type']
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Message',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_attachment(self, project_id, attachment_id, object_type, object_id, **kwargs):
        """
        Gets an Attachment of an Object
        To retrieve an Attachment from a Release, Build, Requirement, Test Case, Test Log, Test Step or Defect
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_attachment(project_id, attachment_id, object_type, object_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: ID of the project (required)
        :param int attachment_id: ID of attachment (required)
        :param str object_type: Valid values include <em>release</em>, <em>build</em>, <em>requirements</em>, <em>test-cases</em>, <em>test-logs</em>, <em>test-steps</em>, or <em>defects</em> (required)
        :param int object_id: ID of the object (Release, Build, Requirement, Test Case, Test Log, Test Step or Defect) (required)
        :return: OutputStream
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_attachment_with_http_info(project_id, attachment_id, object_type, object_id, **kwargs)
        else:
            (data) = self.get_attachment_with_http_info(project_id, attachment_id, object_type, object_id, **kwargs)
            return data

    def get_attachment_with_http_info(self, project_id, attachment_id, object_type, object_id, **kwargs):
        """
        Gets an Attachment of an Object
        To retrieve an Attachment from a Release, Build, Requirement, Test Case, Test Log, Test Step or Defect
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_attachment_with_http_info(project_id, attachment_id, object_type, object_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: ID of the project (required)
        :param int attachment_id: ID of attachment (required)
        :param str object_type: Valid values include <em>release</em>, <em>build</em>, <em>requirements</em>, <em>test-cases</em>, <em>test-logs</em>, <em>test-steps</em>, or <em>defects</em> (required)
        :param int object_id: ID of the object (Release, Build, Requirement, Test Case, Test Log, Test Step or Defect) (required)
        :return: OutputStream
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'attachment_id', 'object_type', 'object_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_attachment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_attachment`")
        # verify the required parameter 'attachment_id' is set
        if ('attachment_id' not in params) or (params['attachment_id'] is None):
            raise ValueError("Missing the required parameter `attachment_id` when calling `get_attachment`")
        # verify the required parameter 'object_type' is set
        if ('object_type' not in params) or (params['object_type'] is None):
            raise ValueError("Missing the required parameter `object_type` when calling `get_attachment`")
        # verify the required parameter 'object_id' is set
        if ('object_id' not in params) or (params['object_id'] is None):
            raise ValueError("Missing the required parameter `object_id` when calling `get_attachment`")


        collection_formats = {}

        resource_path = '/api/v3/projects/{projectId}/{objectType}/{objectId}/attachments/{attachmentId}'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']
        if 'attachment_id' in params:
            path_params['attachmentId'] = params['attachment_id']
        if 'object_type' in params:
            path_params['objectType'] = params['object_type']
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='OutputStream',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_attachments_of(self, project_id, object_type, object_id, **kwargs):
        """
        Gets all Attachments of an Object
        To retrieve all Attachments of a Release, Build, Requirement, Test Case, Test Log, Test Step or Defect
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_attachments_of(project_id, object_type, object_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: ID of the project (required)
        :param str object_type: Valid values include <em>release</em>, <em>build</em>, <em>requirements</em>, <em>test-cases</em>, <em>test-logs</em>, <em>test-steps</em>, or <em>defects</em> (required)
        :param int object_id: ID of the object (Release, Build, Requirement, Test Case, Test Log, Test Step or Defect) (required)
        :return: list[AttachmentResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_attachments_of_with_http_info(project_id, object_type, object_id, **kwargs)
        else:
            (data) = self.get_attachments_of_with_http_info(project_id, object_type, object_id, **kwargs)
            return data

    def get_attachments_of_with_http_info(self, project_id, object_type, object_id, **kwargs):
        """
        Gets all Attachments of an Object
        To retrieve all Attachments of a Release, Build, Requirement, Test Case, Test Log, Test Step or Defect
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_attachments_of_with_http_info(project_id, object_type, object_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: ID of the project (required)
        :param str object_type: Valid values include <em>release</em>, <em>build</em>, <em>requirements</em>, <em>test-cases</em>, <em>test-logs</em>, <em>test-steps</em>, or <em>defects</em> (required)
        :param int object_id: ID of the object (Release, Build, Requirement, Test Case, Test Log, Test Step or Defect) (required)
        :return: list[AttachmentResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'object_type', 'object_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_attachments_of" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_attachments_of`")
        # verify the required parameter 'object_type' is set
        if ('object_type' not in params) or (params['object_type'] is None):
            raise ValueError("Missing the required parameter `object_type` when calling `get_attachments_of`")
        # verify the required parameter 'object_id' is set
        if ('object_id' not in params) or (params['object_id'] is None):
            raise ValueError("Missing the required parameter `object_id` when calling `get_attachments_of`")


        collection_formats = {}

        resource_path = '/api/v3/projects/{projectId}/{objectType}/{objectId}/attachments'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']
        if 'object_type' in params:
            path_params['objectType'] = params['object_type']
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[AttachmentResource]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def search(self, project_id, type, **kwargs):
        """
        Searches for Attachments
        To query for attachments of <em>Releases</em>, <em>Builds</em>, <em>Requirements</em>, <em>Test Cases</em>, <em>Test Logs</em>, <em>Test Steps</em> or <em>Defects</em>
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.search(project_id, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: ID of the project (required)
        :param str type: Its valid values include <em>releases</em>, <em>builds</em>, <em>requirements</em>, <em>test-cases</em>, <em>test-steps</em>, <em>test-logs</em> or <em>defects</em> (required)
        :param list[int] ids: List of object IDs (of the same type as specified in the parameter above), separated by commas
        :param int author: ID of the user who created the attachment
        :param str created_date: Its format is: <strong>{operator} {createdDate in timestamp or UTC}</strong>  The <em>operator</em> can be one of the following values:  <b>lt</b>: less than the given date  <b>gt</b>: greater than given date  <b>eq</b>: equal to the given date  <b>le</b>: less than or equal to the given date  <b>ge</b>: greater then or equal to the given date
        :param int page_size: The result is paginated. By the default, the number of objects in each page is 100 if this is omitted. You can specify your custom number (up to 999) in this parameter
        :param int page: By default, the first page is returned but you can specify any page number to retrieve attachments
        :return: PagedResourceAttachmentResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.search_with_http_info(project_id, type, **kwargs)
        else:
            (data) = self.search_with_http_info(project_id, type, **kwargs)
            return data

    def search_with_http_info(self, project_id, type, **kwargs):
        """
        Searches for Attachments
        To query for attachments of <em>Releases</em>, <em>Builds</em>, <em>Requirements</em>, <em>Test Cases</em>, <em>Test Logs</em>, <em>Test Steps</em> or <em>Defects</em>
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.search_with_http_info(project_id, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: ID of the project (required)
        :param str type: Its valid values include <em>releases</em>, <em>builds</em>, <em>requirements</em>, <em>test-cases</em>, <em>test-steps</em>, <em>test-logs</em> or <em>defects</em> (required)
        :param list[int] ids: List of object IDs (of the same type as specified in the parameter above), separated by commas
        :param int author: ID of the user who created the attachment
        :param str created_date: Its format is: <strong>{operator} {createdDate in timestamp or UTC}</strong>  The <em>operator</em> can be one of the following values:  <b>lt</b>: less than the given date  <b>gt</b>: greater than given date  <b>eq</b>: equal to the given date  <b>le</b>: less than or equal to the given date  <b>ge</b>: greater then or equal to the given date
        :param int page_size: The result is paginated. By the default, the number of objects in each page is 100 if this is omitted. You can specify your custom number (up to 999) in this parameter
        :param int page: By default, the first page is returned but you can specify any page number to retrieve attachments
        :return: PagedResourceAttachmentResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'type', 'ids', 'author', 'created_date', 'page_size', 'page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `search`")
        # verify the required parameter 'type' is set
        if ('type' not in params) or (params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `search`")


        collection_formats = {}

        resource_path = '/api/v3/projects/{projectId}/attachments'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}
        if 'type' in params:
            query_params['type'] = params['type']
        if 'ids' in params:
            query_params['ids'] = params['ids']
            collection_formats['ids'] = 'multi'
        if 'author' in params:
            query_params['author'] = params['author']
        if 'created_date' in params:
            query_params['createdDate'] = params['created_date']
        if 'page_size' in params:
            query_params['pageSize'] = params['page_size']
        if 'page' in params:
            query_params['page'] = params['page']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PagedResourceAttachmentResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def upload(self, project_id, object_type, object_id, file_name, content_type, body, **kwargs):
        """
        Uploads an Attachment to an Object
        To upload an Attachment to a Release, Build, Requirement, Test Case, Test Log, Test Step, or Defect
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload(project_id, object_type, object_id, file_name, content_type, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: ID of the project (required)
        :param str object_type: Valid values include releases, builds, requirements, test-cases, test-logs, test-steps or defects  <strong>qTest Manager version:</strong> 4+ (required)
        :param int object_id: ID of the object (Release, Build, Requirement, Test Case, Test Log, Test Step or Defect) (required)
        :param str file_name: (required)
        :param str content_type: (required)
        :param str body: (required)
        :return: AttachmentResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.upload_with_http_info(project_id, object_type, object_id, file_name, content_type, body, **kwargs)
        else:
            (data) = self.upload_with_http_info(project_id, object_type, object_id, file_name, content_type, body, **kwargs)
            return data

    def upload_with_http_info(self, project_id, object_type, object_id, file_name, content_type, body, **kwargs):
        """
        Uploads an Attachment to an Object
        To upload an Attachment to a Release, Build, Requirement, Test Case, Test Log, Test Step, or Defect
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_with_http_info(project_id, object_type, object_id, file_name, content_type, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: ID of the project (required)
        :param str object_type: Valid values include releases, builds, requirements, test-cases, test-logs, test-steps or defects  <strong>qTest Manager version:</strong> 4+ (required)
        :param int object_id: ID of the object (Release, Build, Requirement, Test Case, Test Log, Test Step or Defect) (required)
        :param str file_name: (required)
        :param str content_type: (required)
        :param str body: (required)
        :return: AttachmentResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'object_type', 'object_id', 'file_name', 'content_type', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `upload`")
        # verify the required parameter 'object_type' is set
        if ('object_type' not in params) or (params['object_type'] is None):
            raise ValueError("Missing the required parameter `object_type` when calling `upload`")
        # verify the required parameter 'object_id' is set
        if ('object_id' not in params) or (params['object_id'] is None):
            raise ValueError("Missing the required parameter `object_id` when calling `upload`")
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params) or (params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `upload`")
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params) or (params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `upload`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `upload`")


        collection_formats = {}

        resource_path = '/api/v3/projects/{projectId}/{objectType}/{objectId}/blob-handles'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']
        if 'object_type' in params:
            path_params['objectType'] = params['object_type']
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']

        query_params = {}

        header_params = {}
        if 'file_name' in params:
            header_params['File-Name'] = params['file_name']
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']

        form_params = []
        local_var_files = {}
        if 'body' in params:
            form_params.append(('body', params['body']))

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AttachmentResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
